#!/usr/bin/python
# -*- coding: utf-8 -*-

# This file is part of Cockpit.
#
# Copyright (C) 2013 Red Hat, Inc.
#
# Cockpit is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 2.1 of the License, or
# (at your option) any later version.
#
# Cockpit is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with Cockpit; If not, see <http://www.gnu.org/licenses/>.

from testlib import *

import socket
import time

def wait_for_port (addr, port):
    tries = 0
    while tries < 20:
        try:
            socket.create_connection ((addr, port)).close()
            return
        except:
            time.sleep(0.2)
        tries += 1
    assert False

def get_webapp_machines(browser):
    wm = { }
    cockpit = browser.eval_js('return cockpit_machines.map(function (m) { return m.address });')
    for i in range (0, len(cockpit)):
        wm[cockpit[i]] = i;
    return wm

def machine_selector(machine):
    return '#dashboard-machines li:nth-child(%d)' % (machine+1)

def action_selector(machine):
    return machine_selector(machine) + ' .cockpit-machine-action'

def graph_selector(machine):
    return machine_selector(machine) + ' .cockpit-graph'

def hostname_selector(machine):
    return machine_selector(machine) + ' .cockpit-machine-info > div:nth-child(1)'

def machine_error_selector(machine):
    return machine_selector(machine) + ' .cockpit-machine-error'

class TestMultiMachine(MachineCase):
    def setUp(self):
        MachineCase.setUp(self)
        self.machine2 = self.new_machine()
        self.machine2.start()
        self.machine2.wait_boot()

        self.machine3 = self.new_machine()
        self.machine3.start()
        self.machine3.wait_boot()

    def tearDown(self):
        self.check_journal_messages(self.machine2)
        self.check_journal_messages(self.machine3)
        MachineCase.tearDown(self)

    def testBasic(self):
        b = self.browser
        m1 = self.machine
        m2 = self.machine2
        m3 = self.machine3

        wait_for_port(m2.address, 22)
        wait_for_port(m3.address, 22)

        m1.execute ("hostnamectl set-hostname machine-1")
        m2.execute ("hostnamectl set-hostname machine-2")
        m3.execute ("hostnamectl set-hostname machine-3")

        self.login_and_go("dashboard")
        b.wait_in_text('#dashboard-machines', "machine-1")

        b2 = self.new_browser()
        b2.login_and_go("dashboard")
        b2.wait_in_text('#dashboard-machines', "machine-1")

        # Add machine-2.
        b.click('#dashboard-add-server')
        b.wait_popup('dashboard_add_server_dialog')
        b.set_val('#dashboard_add_server_address', m2.address)
        b.click('#dashboard_add_server_add')
        b.wait_popdown('dashboard_add_server_dialog')
        b.wait_in_text('#dashboard-machines', "machine-2")

        # It should appear in b2 as well.
        b2.wait_in_text('#dashboard-machines', "machine-2")

        wm = get_webapp_machines(b)
        m1_index = wm["localhost"]
        m2_index = wm[m2.address]

        # Kill the sessions on machine-2
        m2.execute("loginctl kill-user admin")
        b.wait_text(machine_error_selector(m2_index), "Your session has been terminated.")
        b2.wait_text(machine_error_selector(m2_index), "Your session has been terminated.")

        # Reconnect to machine-2
        b.wait_text (action_selector (m2_index), "Connect")
        b.click (action_selector (m2_index))
        b.wait_visible (graph_selector (m2_index))

        # Kill the sessions on machine-1.  This will prevent machine-3
        # from being added permanently.
        m1.execute("loginctl kill-user admin")
        b.wait_text(machine_error_selector(m1_index), "Your session has been terminated.")
        b.wait_visible('#dashboard-local-disconnected')
        b.wait_text('#dashboard-local-error', "Your session has been terminated.")
        b2.wait_visible('#dashboard-local-disconnected')
        b2.wait_text('#dashboard-local-error', "Your session has been terminated.")

        # Add machine-3
        b.click('#dashboard-add-server')
        b.wait_popup('dashboard_add_server_dialog')
        b.set_val('#dashboard_add_server_address', m3.address)
        b.click('#dashboard_add_server_add')
        b.wait_popdown('dashboard_add_server_dialog')

        b.wait_popup('error-popup')
        b.click("#error-popup button")
        b.wait_popdown("error-popup")

        b.wait_in_text('#dashboard-machines', "machine-3")
        assert m3.address not in m1.execute("grep machines /var/lib/cockpit/machines");

        # Reconnect both browsers to localhost.  This will cause machine-3 to be
        # added permanently and appear in the second browser.
        b.click('#dashboard-local-reconnect')
        b.wait_not_visible('#dashboard-local-disconnected')
        b2.click('#dashboard-local-reconnect')
        b2.wait_not_visible('#dashboard-local-disconnected')
        b2.wait_in_text('#dashboard-machines', "machine-3")

        b2.snapshot("B2")

        self.allow_journal_messages("Warning: Permanently added '.*' \\(RSA\\) to the list of known hosts.",
                                    "peer did not close io when expected")

test_main()
